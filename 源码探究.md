# 源码解析



## 一：HashMap源码

> 使用的源码是jdk1.8

Hash的底层数据结构使用的是数组加链表。

数组存的链表的头节点。

链表存的是相似的Key-value组成的节点。

另外还要说的几个名词

1. 负载因子loadFactor，用来描述HashMap的填充情况，和当前容量相乘可以获取内部数组下一次扩充的大小
2. 当前容量size，就是现在这个HashMap存了多少元素。
3. 阈值threshold，一开始阈值就是内部数组大小，后面就是专门值的是阈值了。用负载因子*size可得

每一次put元素到HashMap中，都会检查当前容量再+1的话，是否大于容量大小

如果是，则会进行扩容。

## 1.1 put源码

1. 首先使用内部哈希函数计算Key的哈希值

2. 判断HashMap内部数组是否为空，是，先创建一个新的内部数组

3. 通过一个算式，计算该key值应该对应到数组的哪个角标下面，并判断该角标元素是否存在。

   > 一开始不清楚这个算式的作用，后来考虑了一下，它应该是作为一个初级的相同Key的检测。
   >
   > 如果这次put的key之前已经put过了，那么用这个方法就能迅速的定位到那个相同key的元素。
   >
   > 当然，之所以要说它初级，是因为不同的条件，可能算出来的角标元素是一样的。

   如果该角标元素存在，则遍历该元素，也就是链表，遍历每一个元素，是否和put的key一样

   > 是否和xxx一样的判断标准
   >
   > 1. 哈希值是否一样
   > 2. 地址是否一样
   > 3. 是否equals

   ​	如果遍历到链表有一个元素的key和put的key一样，那么就更新一些新值，然后结束方法执行

   ​	如果遍历不到与之相同的key元素，则往链表的最后面填充一个新的节点

   如果该元素角标不存在，则在该角标下面创建一个新的链表，并且有一个头结点。

4. 将当前容量自增，并判断是否大于阈值，如果是，进行扩容。

   大致就是如此。

我的想法：不管是用算式算出key值应该对应哪个角标也好，还是用链表和数组作为底层数据结构也好

在我看来，这其实都是对快速查询相同key的一个妥协。

不信？你试试HashMap的数据结构直接使用数组来存储，看看有什么缺点。

