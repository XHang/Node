# JVM 调优

# 第一章：概述

想继续JVM调优，必须先理解JVM虚拟机的内存模型

总的来说，JVM的堆内存在物理上分为两部分

1. **Young Generation** （年轻一代）
2. **Old Generation** （老一代）





# 第二章：年轻一代

young Generation是所有新对象创建的地方

当young generation 充满时，垃圾回收就会开始执行

> 这种垃圾回收被称为`Minor GC`

Young Generation分为三个部分

即一个`Eden Memory` 和两个`Survivor Memory`

有关Young Generation的几个重要观点

1. 绝大多数新对象创建的内存区域，都是在`Eden Memory`里面

2. 当`Eden Memory`充满时，JVM会执行`Minor GC` ,并将还存活的对象全都移动到其中一个

   `Survivor Memory`内存区域中去

3. `Minor GC` 也会检查`Survivor Memory`内存区域中存活的对象，并将其移动到另一个`Survivor Memory`内存中。所以每次执行完后，其中一个`Survivor Memory`内存区域总是空的

4. 经过多次`Minor GC`的摧残后还能活下来的对象，将被移动到养老院，也就是**Old Generation** （老一代）的内存空间。

   到底有多少次`Minor GC`呢？这就涉及到一个门槛问题了   ​
# 第三章：年老一代

Old Generation 内存中包含的对象一般都是活的很久，并经过多次的垃圾回收后还存活的。

通常垃圾回收是在Old Generation的内存满的时候中执行的。

Old Generation的垃圾回收又被称为`Major GC` 通常需要更多的时间

# 第四章 ：垃圾回收

一个很重要的特性：

所有垃圾回收都是`时间静止`时间，也就是说，当垃圾回收执行时，所有应用程序线程都会停止，直至操作完成

# 第五章:性能测试

一般来说,软件开发的传统过程是这样的

分析-设计-编码-测试.

但是测试仅仅只是测试功能是否满足需求.

至于性能或者扩展性,那是之后的事了.

当然这样可不行,所以后来才会出现性能测试分析阶段.

要通过这个阶段测试性能是否满足要求

如果不满足,需要返回分析,设计,编码的某个阶段.具体探讨是哪一部分导致了性能问题.

如果满足了,产品才可以继续发布.

当然在需求文档中,必须要有性能需求,不然探讨性能优化就毫无原因了.

举几个吞吐量和延迟性需求

1. 应用预期的吞吐量是多少?

2. 请求和响应之间的延迟预期是多少?

3. 应用支持多少并发任务

4. 把并发任务达到最大值时,应用程序可接受的吞吐量和延迟量是多少?

5. 最差情况的延迟量是多少

6. 如果要使垃圾收集导致的延迟控制在可容忍访问内,

   则垃圾收集的频率应该设计为多少








# 第六章:性能调优方案

## 3.1 定义

改善性能一般涉及到三种不同的活动

1. 性能监控

   指的是非侵入式的收集应用的性能数据的活动.

   一般在找不到性能问题的根本原因时,使用这种方法

   由于是非侵入式,可以在开发,测试,生产环境中使用

2. 性能分析

   这是一种侵入式的收集性能数据的活动,会影响应用的吞吐性或者响应性

   通常在性能监控后执行

3. 性能调优

   这是为了改善应用响应性或者吞吐性的而更改参数,源代码,或者属性配置的活动.

   一般在性能监控或者性能调优后执行

## 第一种:自顶向下

简而言之,就是从软件的栈顶层应用,从上到下一步步寻找优化机会和问题

应用开发人员常用这种方式.

这种方式一般是从发现性能问题的区域(负载)开始监控应用.

监控的范围包括操作系统,JAVA虚拟机,JAVAEE容器以及应用的性能测试统计指标

基于监控信息,来开展下一步工作,比如JVM垃圾收集器调优,JVM命令行选项调优

操作系统调优.





## 第二种:自底向上

就是从最底层的CPU指令数据(比如说CPU高速缓存未命中率,CPU指令效率)开始,逐渐上升到应用的架构上.

将应用迁移到其他操作系统时,或者应用以及部署到生产环境时,也常常使用这种方法

自底向上需要收集最底层CPU的性能统计数据

​	包括执行特定任务所需要的CPU指令数(通常称为路径长度 Path Length)

​	应用在一定负载下运行的CPU高速缓存未命中率.

自底向上一般关注的是不改动应用的情况下,改善CPU使用率.不过通常自底向上也可以为如何修改应用提供建议

# 第七章:选择合适的CPU架构

有时候，性能差仅仅是运行的ＣＰＵ架构或者系统不合适．所以，为应用选择一个合适的ＣＰＵ架构就显得尤为重要．

一般来说，**如果你的应用会有比较多的并发线程，那么推荐的ＣＰＵ架构就是每核多硬件线程**

系统会把每一核的每一个硬件线程都看作一个处理器．

这样的话，在发生长延迟时，比如说ＣＰＵ高速缓存未命中,如果同一个ＣＰＵ核中还有其他就绪的硬件线程，

那么，在下一个时钟周期，就会让这个硬件线程运行，从而减少等待时间．

相反，如果你用的是每核单硬件线程，当发生长延迟事件，就只能等事件完成而浪费时间周期．

并且，如果其他线程已经就绪却没有可用的硬件线程，那么运行前就必须进行线程的切换，而切换，一般要数百个时钟周期．

但是，对于不需要大量并发的应用而言，就没必要选用每核多硬件线程的ＣＰＵ，何况这种ＣＰＵ，它的时钟频率通常比较低，比单核单硬件线程的还要低．

**这种应用的话，还是老老实实选用单核单硬件线程的ＣＰＵ吧**

> 为了评估单核多硬件ＣＰＵ的性能，一般是要加载大量的并发线程的
>
> 另外，单核多硬件线程的ＣＰＵ典型代表型号是Ｏｒａｃｌｅ公司出品的ＳＰＡＲＣ T 系列处理器

# 第八章：操作系统的性能监控

## 5.1 cpu使用率

毋庸置疑,想让应用的性能达到最高,就必须充分榨干CPU周期.

> 值得注意的是,应用消耗很多CPU并不意味着性能达到最高

要找出应用如何使用CPU周期,就要监控CPU使用率.

CPU使用率分为两种

1. 用户型CPU使用率:指的是执行应用程序代码的时间占总CPU时间的百分比

2. 系统型CPU使用率:应用执行操作系统设备调用的时间占总CPU时间的百分比.

   这个CPU使用率高的话,说明应用有共享资源竞争或者IO设备之间有大量的交互

理想情况下,系统型CPU使用率为0时,应用会达到最高的性能.

但是理想是达不到的,我们只能尽量降低系统型CPU使用率

### 5.1.2 监控CPU使用率的工具：Ｌｉｎｕｘ

1. 图形界面

ＬＩＮＵX可以使用ＧＮＯＭＥ System Monitor

通过这个命令启动

`fdggnome-system-monitor ` 

据说只能普通用户启动，超级用户看不到资源和文件系统的栏目

听说还可以用ｘｏｓｖｉｅｗ看ｃｐｕ使用率，但是我用了之后就死机了．．

2. 命令行

   通常用`vmstat`来监控ＣＰＵ使用率，听说加个-w参数会比较好哦

   另外，显示出来的us 是用户型ｃｐｕ使用率，sy是系统型cpu使用率，id是cpu空闲率

   也可以用ｔｏｐ监控ＣＰＵ使用率使用率

   ​

##　5.2:番外篇

对于计算密集型应用，还要关注它的每时钟指令数以及每指令时钟周期．

> 一般平台提供的ＣＰＵ使用率监控是看不到每时钟指令数以及每指令时钟周期的
>
> 所以需要其他骚操作来监控这两货

这是因为即使ＣＰＵ在等待内存中的数据，操作系统工具还是会说ＣＰＵ繁忙．

这种情况被称为停滞，这种停滞还会浪费数几百个时钟周期．

想要提高计算密集型应用的性能时，就要尽量减少停滞和提高ＣＰＵ高速缓存使用率

## 5.3:CPU调度程序运行队列

除了cpu使用率之外,监控cpu调度程序运行队列对于分辨系统是否满负荷也是具有重要的意义.

如果调度程序运行队列很长,则表名系统可能已经满负荷.

当系统运行队列长度等于虚拟处理器个数时,用户不会感受到性能下降.

> 虚拟处理器个数=系统硬件线程个数=Runtime.getRuntime().availableProcessors();

如果系统运行队列长度达到虚拟核心数的4倍或者更多时,系统的响应就很迟缓了

一般说来,只要队列的长度超过虚拟处理器个数的1倍,需要盯紧他,不需要采取行动

如果是超过3-4倍以及更高,就需要采取行动了.

行动1:增加cpu

行动2:研究可以减少应用运行所需cpu周期的葵花宝典,改进cpu使用率

​	比如减少垃圾搜集的频率或者采用更优的算法以减少cpu指令

### 5.3.1 linux上的监控调度程序运行队列

还是要请我们的老朋友`vmstat`

其结果的第一列`procs`就是运行队列长度



## 5.4:内存使用率

内存使用率当然也是衡量性能的一个重要指标.

当运行所需内存超过物理可用内存时,就会发生页面交换.

就是将不常用的内存放进磁盘的swap空间.当要访问到这部分内存时,就要把它从磁盘上置换到内存中,而这种置换会对应用的响应性和吞吐量造成很大的影响.

而且,JVM垃圾搜集器受其系统页面交换,性能也会很差.

其一是因为垃圾搜集要占用很多内存

其二由于占较多内存,则java堆内存的一部分可能会发生页面交换,而垃圾搜集时又得置换进内存以便垃圾收集器扫描存活对象.这使得垃圾搜集会占用更多时间.

其三:垃圾搜集时所有java的应用都要停止.然后你懂得

经验:如果垃圾搜集的时间变长,则表明系统可能正在进行页面交换.

为了验证这一点,必须监控系统的页面交换

### 5.4.1:监控内存使用率:linux

还是老朋友`vmstat`命令,其中`free`列就可以监控页面交换.其实它显示的是空闲内存

要关注的还有`si`和`so`列,分别表示内存页面换入和换出的量.

要留意是否会出现空闲内存少,并且页面调度频繁的情况,相比而言,数量并不是很重要..

## 5.5:监控锁竞争

一般情况下，锁都应该是很快获取，很快释放．如果要是遇到有一个线程，迟迟不释放锁，那么其他需要锁的程序就只能空转，不断的尝试获取锁，这样对系统的性能会有较大影响．

接下来，我们就要找出Ｊａｖａ应用中的锁竞争．

首先来了解一些java1.5之后推出的锁竞争，它是怎么运作的

应用通过忙循环自旋尝试获取锁，如果若干次忙循环自旋都不能获取到锁，那么线程挂起，直到下次唤醒时再尝试获取该锁．

而线程挂起和唤醒都会造成`让步式上下文切换`这种切换通常会浪费数万个时钟周期．

那么怎么看程序是不是遇到了锁竞争呢？

对于任何java应用来说，如果让步式上下文切换占用它５％或者更多的时钟周期，说明它遇到了锁竞争

> 顺便说一下抢占式上下文切换，这个切换表明线程由于ＣＰＵ分配的时间片用尽而被迫放弃执行权或者被更高优先度的线程所抢占．和让步式上下文切换不同，后者是自愿放弃ｃｐｕ执行权的
>
> 可以通过`pidstat -w`　查看抢占式上下文切换的数值
>
> 如果抢占式上下文切换的数值较高，则表明系统会有较多的预备运行线程数．
>
> 引发的问题可以看下5.3:CPU调度程序运行队列
>
> 像这种问题的解决方案
>
> 1. 创建处理器组并将应用分配给处理器组运行,linux可以通过`taskset`命令完成
> 2. 减少应用运行的线程数
> 3. 分析应用，优化性能（不常用）

### 5.5.1查看Ｌｉｎｕｘ上的锁竞争

可以通过这个命令来查看`pidstat`

该命令可能需要安装`sysstat`

该命令显示的`cswch/s`就是应用的让步式上下文切换．

根据这个数值怎么判断应用已经遇到了锁竞争呢？

1. 用该`数值*80000`这就是应用由于让步式上下文切换而兰妃的时钟周期

   > 80000就是一个让步式上下文切换而浪费的时钟周期，当然只是估算而已

2. 用得出来的结果除以ＣＰＵ每秒的时钟周期数，就是让步式上下文切换占用的可用时钟周期

   > CPU每秒的时钟周期数，如３Ｇhz CPU每秒的时钟周期数就是`3000000000`

如果发现应用确实存在锁竞争，那么接下来就是在源代码中查找那一部分是有竞争锁的．

一般来说，都是要定期转储线程，查找锁竞争的线程

## 5.6 线程迁移

待处理的线程在处理器之间进行迁移也会导致性能下降．

一般来说，待运行的线程都会分配给上次运行它的处理器。

如果这个处理器正忙，那么将会把待运行的线程迁移到其他处理器上。

这个迁移也会降低应用的性能，这是因为迁移后的处理器一般没有这个线程需要的缓存。

降低线程迁移的一个办法就是创建处理器组并将应用分配给处理器组

一般情况下，如果横跨多核或者虚拟处理器的Ｊａｖａ应用每秒迁移超过500次，那么把应用绑定在处理器组是非常用的。

## 5.7 网络ＩＯ使用率

分布式Java应用的性能受限于网络带宽或者网络io的性能。

所以我们需要监控应用的网络使用率。

在linux上，可以使用这个命令`nicstat` 它可以报告网络使用率和网络接口的饱和度

命令输出的列名含义如下

`Int`网络接口设备名

`rKb/s`每秒读取的ＫＢ数

`wKb/s`每秒写入的ＫＢ数

`rPk/s`每秒读取的包数

`wPk/s`每秒写入的包数

`rAvs`，每秒读取的平均字节数

`wAvs`每秒写入的平均字节数

`%Util`网络接口使用率

`Sat`饱和度

怎么考虑优化网络ＩＯ使用率

单次读写数据量小的网络读写数据量大的应用会消耗大量的系统态ＣＰＵ，产生大量的系统调用

当然想优化的话，就要尽量减少网络读写的系统调用。

使用非堵塞的应用框架NIO也可以显著改善网络性能。

建议使用nio框架而不要使用jdk自带的nio实现，它只是一种原始实现。

## 5.8 磁盘ＩＯ使用率

对于有磁盘操作的应用来说，改善性能，自然就要监控磁盘ＩＯ

linux上可以使用`iostat`来监控磁盘ＩＯ使用率

该命令可以监控磁盘IO使用率和系统态cpu使用率

其中`%system`是系统态ＣＰＵ使用率，然后`%util`是磁盘IO使用率

但是这个命令并不能看出是哪个应用在操作磁盘。

直接跳过吧。。。

### 5.8.1 怎么优化磁盘ＩＯ使用率？

1. 更快的存储设备

2. 文件系统扩展到多个磁盘？

3. 操作系统调优，缓存大量文件系统数据结构？

   此外，还有尽量使用带缓存的输入输出流来减少读写次数。

   以及开启磁盘缓存，可以改善严重依赖磁盘ＩＯ的应用的性能。

   但是如果一旦断电的话，可能会导致数据损坏



# 第九章：JVM概览

本章主要讲述的是jvm的架构以及它的主要组件

JVM主要有以下三个组件

1. JVM运行时
2. JIT编译器
3. 内存管理器

## 9.1 HotSpot　VM的基本架构

基本架构就是

垃圾收集器（可插拔）

JIT编译器（可插拔）

HotSpot VM 运行时

​	HotSpot VM 运行时为JIT编译器和垃圾收集器提供服务和通用的API,此外，它还为VM提供启动，线程管理

​	JNI(Java本地接口)等基本功能

内存相关

java堆内存的大小受限于HotSpot版本和操作系统

早期操作系统和hotspot的版本都比较小，所以能用的内存也会比较小

现在大不相同的了，特别是64位的HotSpot　VM 能用的java堆内存就更大

虽然64的寻址对一些应用可能有帮助，但是64的HotSpot有性能损失。

因为内部的java对象指针从32位变成了64位，导致cpu高速缓存行可用的oops变少，从而降低了cpu缓存的效率

不过后来加了压缩指针，使得64位的大内存和cpu效率可以兼得。要通过-xx:+UseCompressedOops开启。

### 9.2 HotSpot　VM运行时

这货担当许多职责。

1. 命令行解析

2. VM生命周期管理

3. 类加载

4. 字节码解释

5. 异常处理

6. 同步

7. 线程管理

8. java本地接口

9. vm致命错误

10. c++堆管理

#### 9.2.1 JVM命令行

它能做到:可以选定哪个编译器，哪张垃圾搜集器，指定java堆的大小

   命令行选项包含三种

1. 标准选项：要求所有虚拟机都必须实现的选项
2. 非标准选择：不强制要求所有虚拟机都必须实现 开头的选项带有`-x`
3. 非稳定选项 开头的选项带有`--x`

意义:命令行一般是用于控制JVM的内部变量

选项面面观1:

对于内部变量为布尔类型的选项来说,只需要添加或者删除就可以控制这些变量.

对于内部变量为布尔类型的非稳定选项来说,选项前面的`+`或者`-`代表true或者false

例如`--x:+AggressiveOpts`就是设置某个内部变量为true以开启

​	`--x:-AggressiveOpts` 就是设置某个内部变量为false以关闭(默认值)

选项面面观2:

有些选项长这个样子

`--x:OptionName=<N>`

<N>代表数字,像这种带数字的非稳定选项,数字后面都可以带k,m,g表示千,百万及十亿

选项面面观3:

有些选项长得别树一帜,如`XXaltJvm=<name>`

就是`-xx`和选项名之间没有分隔符

甚至有些选项`:` `=`也是没有的



#### 9.9.2 VM生命周期

本章主要讲的是java程序运行前,终止或者退出时,jvm做了什么事?

1. 启动

   jvm启动所用的组件是启动器.这启动器有四种

   1. linux系统下的jvm启动器`java`
   2. windows系统下的jvm启动器 `java` or  `javaw`
   3. JNI接口的JNI_CreateJavaVm启动内嵌的jvm
   4. javaws启动器,用于启动applet.`ws`即指的是`web start` 而术语`java web start`就是指`java ws`

   启动器做的操作有

   1. 解析命令行选项

   2. 设置堆的大小,设置JNI编译器

   3. 设定环境变量和读取classpath

   4. 如果,命令行选项里面有`-jar`那么启动器就从指定jar文件里面找`Main-Class`

      否则从命令行读取`Main-class`

   5. 使用java标准本地接口和方法在新创建的线程中创建VM

   6. 一旦创建好vm,那么就开始加在主类了,启动器也会从主类中获取到主方法的参数

   7. vm通过jni方法callstaticvoidmethod调用主方法,并将命令行选项传给他

      至此,jvm开始执行命令行指定的java程序了

2. 关闭

   jvm又做了什么事呢?

   1. 检查和清理程序或者方法执行过程中生成的未处理异常

   2. 调用java本地接口方法`DetachCurrentThread`将java main方法和jvm脱离

      每次脱离,线程数都会-1,所以java本地接口知道什么时候应该安全的关闭VM

      并能确保VM此时并没有执行的操作

3. 遇到错误关闭VM的过程

   当VM启动时,或者运行时遇到很严重的问题,会调用DestroyJavaVM方法停止VM

   过程是这样子的

   1. 一直等待,直到只有一个非守护线程执行(也就是当前线程)

   2. 调用java.lang.Shutdowm.shotdowm(),它会调用java上的ShutDowm钩子方法.

   3. 运行java上的ShutDowm钩子方法,停止一系列线程,并发出状态事件通知jvmTI,然后关闭jvmTI线程.

      最后停止信号线程

   4. 调用Hotspot的javaThread::exit()释放JNI处理块,移除保护页.将当前线程从已知的线程队列中移除.

      从此刻起,VM就无法执行任何java代码了

      > 保护页是不可访问的内存页,用于内存访问区域的边界

   5. 停止vm线程,并将vm线程带到安全点,并停止JIT编译器的线程

   6. 停止追踪jni,hotspot vm 及jvmti屏障

   7. 为那些仍然以本地代码运行的线程是设置标记`vm exited`

   8. 删除当前线程

   9. 删除所有输入/输出留,移除perfMenory(性能统计内存资源)资源

   10. 最后返回给调用者


#### 9.9.3 VM类加载

类加载用于描述类名或者接口名映射成class类对象的整个过程

这个过程有三个阶段:1. 加载 2.链接(验证,准备,解析) 3初始化

1. 加载:首先要从类的全限定名获取二进制字节流,定义java类,然后创建这个类的Class对象

   这个过程会抛出

   1. NoClassDefFound 找不到这个类的二进制流
   2. ClassFormatError or UnSupportedClassVersionError 语法检查出错
   3. ClassCircularityError 类的继承层次有错 ,比如说自己做爸爸,自己又做儿子
   4. IncompatibleClassChangeError 也是类的继承层次有错,比如说实现的不是接口,是类

   这个加载过程一般是由类加载器来完成的,可以使用系统自己提供的类加载器,也可以自己选择

   关于加载器的更多知识可以看下一章

2. 验证

   不能保证所有被JVM加载的Class都是经过javac编译过来的,为了保证虚拟机自身的安全,通常会对类进行验证

   验证包括以下过程

   1. 文件格式的验证,保证这个class文件的格式是符合规范的,并能被当前版本的虚拟机所识别.

      经过该验证,Class文件就会load到内存内

   2. 对元数据进行校验(对类中各个数据类型进行语法校验)

   3. 对类的方法体进行分析,保证方法体不会作出危害虚拟机的行为

   4. 符号引用验证,,对类以外的信息进行匹配性的校验

3. 准备

   该过程主要是为类变量在方法区分配内存,并设置初始值的阶段

   值得注意的是,设置的初始值不是在代码中已经写好的值,而是数据类型默认的初始值

   设置代码中写好的值是在初始化阶段才完成的

   > 比较特别的是,被static final修饰的变量(其实这种情况也叫常量啦),在准备过程中,值就会被初始化成指定的值

4. 解析

   解析阶段是对常量池中的符号引用转换为直接引用的过程

   > 符号引用就是Class文件在编译过程中,生成的三类常量
   >
   > 1.类和接口的全限定名
   >
   > 2.字段的名称和描述符
   >
   > 3.方法的名称和描述符
   >
   > 转换为直接应用的过程就是分析这些符号应用,翻译成直接引用,load到内存中
   >
   > 什么,直接引用又是什么鬼,嗯,就是能直接指向目标的指针.
   >
   > 如果有了直接引用,那么引用的目标一定在内存中了

   解析不一定在类初始化之前完成,也有可能是之后(将要被使用时才解析)

   根据符号引用的类型,有不同的解析方案

   1. 类或接口的解析:判断要解析的直接引用是数组类型,还是普通对象类型

   2. 字段解析:要查找的是简单名称和字段描述符都匹配的目标字段.

      先查找本类,查找到,over,没有,下一个

      查找父接口-祖父接口-如果没有,下一个

      查找父类-祖父类...直至找到

   3. 类方法解析,跟字段解析是一样的,多了判断方法是属于接口的,还是类的,以及是先搜索父类,再去搜索接口

   4. 接口方法解析,也是基本一样,不过接口方法没有父类,所以只从父接口一级一级向上查找即可

5. 初始化

   该过程就真正的执行了Java代码了,在这个过程,类变量会真正的赋上程序员给它的值,而不是默认的初始值了.

   该过程也是执行类构造器`<clinit>()方法`的过程

   几个小知识:

   1. 该方法是编译器自动收集类变量赋值动作和静态构造代码块合并之后产生的.

   搜集的顺序也就是语句在源文件中的顺序

   > 特别注意的是,静态代码块可以访问在它之前已经定义过的类变量
   >
   > 如果类变量定义在静态代码块后面,那么静态代码块只能赋值,不能访问

   2. `<clinit>()`方法在调用时会调用父类的`<clinit>()`,所以在虚拟机第一个被执行`<clinit>()`的类肯定是Object类,另外这个方法是编译时自动生成的..

   3. 不是所以的接口或者类都有`<clinit>()`方法,如果类没有静态代码块和类变量的赋值操作,那么编译器可以选择不生成该方法

   4. 接口不能使用静态代码块,但是仍然有类变量的赋值操作,所以还是可以生成`<clinit>()`方法的

   5. 执行接口的`<clinit>`方法时并不会调用父类的`<cliinit>`方法

   6. 接口的实现类执行`<clinit>`方法时并不会调用接口类的`<clinit>`方法

   7. `<clinit>()`方法是线程安全的,也就是说,活动线程没执行完`<clinit>()`方法的话,

      其他想执行这个方法的线程都得等,万一这个方法执行的过程很长,那么就会造成线程堵塞

   8. 什么时候会执行`clinit>()`方法呢?其实也是在问,什么时候会进行类的初始化呢?

      当类的方法或者字段被访问到时.---(个人观点)

      > 值得注意的是,调用子类去访问父类的字段时,子类并不会初始化
      >
      > 因为这个字段还是属于父类的,不是子类的

      完毕!

      ​

   ​

   ​

   ​

而这个过程需要hotspot vm和java se 类加载库来共同协作.

其中,vm负责解析常量池符号,这个过程需要加载,链接,然后初始化java类和java接口

**那么,什么时候会触发类加载呢?**

1. vm自身引发
2. Class.forName()
3. ClassLoader.loadClass()
4. 反射API以及JNI_FindClass引发类加载

> **关于类加载的几个小知识**
>
> 1. vm启动时,除了加载普通类,也会加载诸如java.lang.Object和Java.lang.Thread这些核心类
> 2. 加载类也需要加载它的所有超类和所有超接口
> 3. 作为链接阶段的一部分,类验证也需要加载其他类

#### 9.3.4 类加载器

对于我们程序员来说,类加载器总共就三种

1. 启动类加载器,这个是用c++编写的类加载器,是虚拟机的一部分

   这个类加载器负责加载jdk/jre/lib目录下面的,或者`-Xbootclasspath`参数指定的路径中类库

   对于许多包名是`java` or  `javax` 来说,这些包里面的类总是会委托给启动类加载器来加载

2. 扩展类加载器,负责加载`JDK\jre\lib\ext`目录中类

3. 应用程序类加载器,这个的话,负责加载classpath下面的类

   > 其实还不止这些类记载器,Oracle还规范了四五个类加载器,这里就不讲了

   java应用程序都是通过以上的类加载器进行加载的,我们也可以自定义自己的类加载器

   > 那么什么时候会用到自定义类加载器呢?

加载器有一个层次关系,又称双亲委派模型(这名字谁起的,怪异)

这个层次关系是这样的

启动类加载器<<<<<扩展类加载器<<<<<应用程序加载器<<<<<自定义加载器

> 其实这个是简化的层次关系,你要知道,类加载器不止这四种

当一个类加载器接收到类加载请求时,它会委派它的上一级类加载器去加载该类.

所以一般来说,所有类加载请求最终都会交由启动类加载器进行加载

> 不一般来说,如果上级的类加载器都不能加载该类,那只能由它自己尝试加载类了

这种机制被称为类加载器委派.

这种机制最重要的用处就是确定JVM中类的唯一性.

因为JVM中类的唯一性是由类的全限定名和类加载器来确定的

> 这你就懂了吧,为了确保jvm里面的类,其类名不会冲突
>
> 这也就意味着,就算类的全限定名相同,只要是由两个不同的类记载器加载的,那么就不是同一个类
>
> equals方法都是挂的,当然,这种情况java程序就不稳定了,必须杜绝这种情况

顺便提一下定义类加载器和初始类加载器

类的首个加载器被称为初始类加载器,然后这个初始类加载器会委托另一个类加载器去加载类.

这个真正加载类的类加载器被称为定义类加载器.

比如说,A类引用了B类,那么对B进行常量池符号解析的类加载器被称为A的定义类加载器,B的初始类加载器



​	



