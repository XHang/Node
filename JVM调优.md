# JVM 调优

# 第一章：概述

想继续JVM调优，必须先理解JVM虚拟机的内存模型

总的来说，JVM的堆内存在物理上分为两部分

1. **Young Generation** （年轻一代）
2. **Old Generation** （老一代）





# 第二章：年轻一代

young Generation是所有新对象创建的地方

当young generation 充满时，垃圾回收就会开始执行

> 这种垃圾回收被称为`Minor GC`

Young Generation分为三个部分

即一个`Eden Memory` 和两个`Survivor Memory`

有关Young Generation的几个重要观点

1. 绝大多数新对象创建的内存区域，都是在`Eden Memory`里面

2. 当`Eden Memory`充满时，JVM会执行`Minor GC` ,并将还存活的对象全都移动到其中一个

   `Survivor Memory`内存区域中去

3. `Minor GC` 也会检查`Survivor Memory`内存区域中存活的对象，并将其移动到另一个`Survivor Memory`内存中。所以每次执行完后，其中一个`Survivor Memory`内存区域总是空的

4. 经过多次`Minor GC`的摧残后还能活下来的对象，将被移动到养老院，也就是**Old Generation** （老一代）的内存空间。

   到底有多少次`Minor GC`呢？这就涉及到一个门槛问题了   ​
# 第三章：年老一代

Old Generation 内存中包含的对象一般都是活的很久，并经过多次的垃圾回收后还存活的。

通常垃圾回收是在Old Generation的内存满的时候中执行的。

Old Generation的垃圾回收又被称为`Major GC` 通常需要更多的时间

# 第四章 ：垃圾回收

一个很重要的特性：

所有垃圾回收都是`时间静止`时间，也就是说，当垃圾回收执行时，所有应用程序线程都会停止，直至操作完成

# 第五章:性能测试

一般来说,软件开发的传统过程是这样的

分析-设计-编码-测试.

但是测试仅仅只是测试功能是否满足需求.

至于性能或者扩展性,那是之后的事了.

当然这样可不行,所以后来才会出现性能测试分析阶段.

要通过这个阶段测试性能是否满足要求

如果不满足,需要返回分析,设计,编码的某个阶段.具体探讨是哪一部分导致了性能问题.

如果满足了,产品才可以继续发布.

当然在需求文档中,必须要有性能需求,不然探讨性能优化就毫无原因了.

举几个吞吐量和延迟性需求

1. 应用预期的吞吐量是多少?

2. 请求和响应之间的延迟预期是多少?

3. 应用支持多少并发任务

4. 把并发任务达到最大值时,应用程序可接受的吞吐量和延迟量是多少?

5. 最差情况的延迟量是多少

6. 如果要使垃圾收集导致的延迟控制在可容忍访问内,

   则垃圾收集的频率应该设计为多少








# 第六章:性能调优方案

## 3.1 定义

改善性能一般涉及到三种不同的活动

1. 性能监控

   指的是非侵入式的收集应用的性能数据的活动.

   一般在找不到性能问题的根本原因时,使用这种方法

   由于是非侵入式,可以在开发,测试,生产环境中使用

2. 性能分析

   这是一种侵入式的收集性能数据的活动,会影响应用的吞吐性或者响应性

   通常在性能监控后执行

3. 性能调优

   这是为了改善应用响应性或者吞吐性的而更改参数,源代码,或者属性配置的活动.

   一般在性能监控或者性能调优后执行

## 第一种:自顶向下

简而言之,就是从软件的栈顶层应用,从上到下一步步寻找优化机会和问题

应用开发人员常用这种方式.

这种方式一般是从发现性能问题的区域(负载)开始监控应用.

监控的范围包括操作系统,JAVA虚拟机,JAVAEE容器以及应用的性能测试统计指标

基于监控信息,来开展下一步工作,比如JVM垃圾收集器调优,JVM命令行选项调优

操作系统调优.





## 第二种:自底向上

就是从最底层的CPU指令数据(比如说CPU高速缓存未命中率,CPU指令效率)开始,逐渐上升到应用的架构上.

将应用迁移到其他操作系统时,或者应用以及部署到生产环境时,也常常使用这种方法

自底向上需要收集最底层CPU的性能统计数据

​	包括执行特定任务所需要的CPU指令数(通常称为路径长度 Path Length)

​	应用在一定负载下运行的CPU高速缓存未命中率.

自底向上一般关注的是不改动应用的情况下,改善CPU使用率.不过通常自底向上也可以为如何修改应用提供建议

# 第七章:选择合适的CPU架构

有时候，性能差仅仅是运行的ＣＰＵ架构或者系统不合适．所以，为应用选择一个合适的ＣＰＵ架构就显得尤为重要．

一般来说，**如果你的应用会有比较多的并发线程，那么推荐的ＣＰＵ架构就是每核多硬件线程**

系统会把每一核的每一个硬件线程都看作一个处理器．

这样的话，在发生长延迟时，比如说ＣＰＵ高速缓存未命中,如果同一个ＣＰＵ核中还有其他就绪的硬件线程，

那么，在下一个时钟周期，就会让这个硬件线程运行，从而减少等待时间．

相反，如果你用的是每核单硬件线程，当发生长延迟事件，就只能等事件完成而浪费事件周期．

并且，如果其他线程已经就绪却没有可用的硬件线程，那么运行前就必须进行线程的切换，而切换，一般要数百个时钟周期．

但是，对于不需要大量并发的应用而言，就没必要选用每核多硬件线程的ＣＰＵ，何况这种ＣＰＵ，它的时钟频率通常比较低，比单核单硬件线程的还要低．

**这种应用的话，还是老老实实选用单核单硬件线程的ＣＰＵ吧**

> 为了评估单核多硬件ＣＰＵ的性能，一般是要加载大量的并发线程的
>
> 另外，单核多硬件线程的ＣＰＵ典型代表型号是Ｏｒａｃｌｅ公司出品的ＳＰＡＲＣ T 系列处理器

# 第八章：操作系统的性能监控

## 5.1 cpu使用率

毋庸置疑,想让应用的性能达到最高,就必须充分榨干CPU周期.

> 值得注意的是,应用消耗很多CPU并不意味着性能达到最高

要找出应用如何使用CPU周期,就要监控CPU使用率.

CPU使用率分为两种

1. 用户型CPU使用率:指的是执行应用程序代码的时间占总CPU时间的百分比

2. 系统型CPU使用率:应用执行操作系统设备调用的时间占总CPU时间的百分比.

   这个CPU使用率高的话,说明应用有共享资源竞争或者IO设备之间有大量的交互

理想情况下,系统型CPU使用率为0时,应用会达到最高的性能.

但是理想是达不到的,我们只能尽量降低系统型CPU使用率

### 5.1.2 监控CPU使用率的工具：Ｌｉｎｕｘ

1. 图形界面

ＬＩＮＵX可以使用ＧＮＯＭＥ System Monitor

通过这个命令启动

`fdggnome-system-monitor ` 

据说只能普通用户启动，超级用户看不到资源和文件系统的栏目

听说还可以用ｘｏｓｖｉｅｗ看ｃｐｕ使用率，但是我用了之后就死机了．．

2. 命令行

   通常用`vmstat`来监控ＣＰＵ使用率，听说加个-w参数会比较好哦

   另外，显示出来的us 是用户型ｃｐｕ使用率，sy是系统型cpu使用率，id是cpu空闲率

   也可以用ｔｏｐ监控ＣＰＵ使用率使用率

   ​

##　5.2:番外篇

对于计算密集型应用，还要关注它的每时钟指令数以及每指令时钟周期．

> 一般平台提供的ＣＰＵ使用率监控是看不到每时钟指令数以及每指令时钟周期的
>
> 所以需要其他骚操作来监控这两货

这是因为即使ＣＰＵ在等待内存中的数据，操作系统工具还是会说ＣＰＵ繁忙．

这种情况被称为停滞，这种停滞还会浪费数几百个时钟周期．

想要提高计算密集型应用的性能时，就要尽量减少停滞和提高ＣＰＵ高速缓存使用率

## 5.3:CPU调度程序运行队列

除了cpu使用率之外,监控cpu调度程序运行队列对于分辨系统是否满负荷也是具有重要的意义.

如果调度程序运行队列很长,则表名系统可能已经满负荷.

当系统运行队列长度等于虚拟处理器个数时,用户不会感受到性能下降.

> 虚拟处理器个数=系统硬件线程个数=Runtime.getRuntime().availableProcessors();

如果系统运行队列长度达到虚拟核心数的4倍或者更多时,系统的响应就很迟缓了

一般说来,只要队列的长度超过虚拟处理器个数的1倍,需要盯紧他,不需要采取行动

如果是超过3-4倍以及更高,就需要采取行动了.

行动1:增加cpu

行动2:研究可以减少应用运行所需cpu周期的葵花宝典,改进cpu使用率

​	比如减少垃圾搜集的频率或者采用更优的算法以减少cpu指令

### 5.3.1 linux上的监控调度程序运行队列

还是要请我们的老朋友`vmstat`

其结果的第一列`procs`就是运行队列长度



## 5.4:内存使用率

内存使用率当然也是衡量性能的一个重要指标.

当运行所需内存超过物理可用内存时,就会发生页面交换.

就是将不常用的内存放进磁盘的swap空间.当要访问到这部分内存时,就要把它从磁盘上置换到内存中,而这种置换会对应用的响应性和吞吐量造成很大的影响.

而且,JVM垃圾搜集器受其系统页面交换,性能也会很差.

其一是因为垃圾搜集要占用很多内存

其二由于占较多内存,则java堆内存的一部分可能会发生页面交换,而垃圾搜集时又得置换进内存以便垃圾收集器扫描存活对象.这使得垃圾搜集会占用更多时间.

其三:垃圾搜集时所有java的应用都要停止.然后你懂得

经验:如果垃圾搜集的时间变长,则表明系统可能正在进行页面交换.

为了验证这一点,必须监控系统的页面交换

### 5.4.1:监控内存使用率:linux

还是老朋友`vmstat`命令,其中`free`列就可以监控页面交换.其实它显示的是空闲内存

要关注的还有`si`和`so`列,分别表示内存页面换入和换出的量.

要留意是否会出现空闲内存少,并且页面调度频繁的情况,相比而言,数量并不是很重要..

## 5.5:监控锁竞争

一般情况下，锁都应该是很快获取，很快释放．如果要是遇到有一个线程，迟迟不释放锁，那么其他需要锁的程序就只能空转，不断的尝试获取锁，这样对系统的性能会有较大影响．

接下来，我们就要找出Ｊａｖａ应用中的锁竞争．

首先来了解一些java1.5之后推出的锁竞争，它是怎么运作的

应用通过忙循环自旋尝试获取锁，如果若干次忙循环自旋都不能获取到锁，那么线程挂起，直到下次唤醒时再尝试获取该锁．

而线程挂起和唤醒都会造成`让步式上下文切换`这种切换通常会浪费数万个时钟周期．

那么怎么看程序是不是遇到了锁竞争呢？

对于任何java应用来说，如果让步式上下文切换占用它５％或者更多的时钟周期，说明它遇到了锁竞争

> 顺便说一下抢占式上下文切换，这个切换表明线程由于ＣＰＵ分配的时间片用尽而被迫放弃执行权或者被更高优先度的线程所抢占．和让步式上下文切换不同，后者是自愿放弃ｃｐｕ执行权的
>
> 可以通过`pidstat -w`　查看抢占式上下文切换的数值
>
> 如果抢占式上下文切换的数值较高，则表明系统会有较多的预备运行线程数．
>
> 引发的问题可以看下5.3:CPU调度程序运行队列
>
> 像这种问题的解决方案
>
> 1. 创建处理器组并将应用分配给处理器组运行,linux可以通过`taskset`命令完成
> 2. 减少应用运行的线程数
> 3. 分析应用，优化性能（不常用）

### 5.5.1查看Ｌｉｎｕｘ上的锁竞争

可以通过这个命令来查看`pidstat`

该命令可能需要安装`sysstat`

该命令显示的`cswch/s`就是应用的让步式上下文切换．

根据这个数值怎么判断应用已经遇到了锁竞争呢？

1. 用该`数值*80000`这就是应用由于让步式上下文切换而兰妃的时钟周期

   > 80000就是一个让步式上下文切换而浪费的时钟周期，当然只是估算而已

2. 用得出来的结果除以ＣＰＵ每秒的时钟周期数，就是让步式上下文切换占用的可用时钟周期

   > CPU每秒的时钟周期数，如３Ｇhz CPU每秒的时钟周期数就是`3000000000`

如果发现应用确实存在锁竞争，那么接下来就是在源代码中查找那一部分是有竞争锁的．

一般来说，都是要定期转储线程，查找锁竞争的线程

## 5.6 线程迁移

待处理的线程在处理器之间进行迁移也会导致性能下降．

一般来说，待运行的线程都会分配给上次运行它的处理器。

如果这个处理器正忙，那么将会把待运行的线程迁移到其他处理器上。

这个迁移也会降低应用的性能，这是因为迁移后的处理器一般没有这个线程需要的缓存。

降低线程迁移的一个办法就是创建处理器组并将应用分配给处理器组

一般情况下，如果横跨多核或者虚拟处理器的Ｊａｖａ应用每秒迁移超过500次，那么把应用绑定在处理器组是非常用的。

## 5.7 网络ＩＯ使用率

分布式Java应用的性能受限于网络带宽或者网络io的性能。

所以我们需要监控应用的网络使用率。

在linux上，可以使用这个命令`nicstat` 它可以报告网络使用率和网络接口的饱和度

命令输出的列名含义如下

`Int`网络接口设备名

`rKb/s`每秒读取的ＫＢ数

`wKb/s`每秒写入的ＫＢ数

`rPk/s`每秒读取的包数

`wPk/s`每秒写入的包数

`rAvs`，每秒读取的平均字节数

`wAvs`每秒写入的平均字节数

`%Util`网络接口使用率

`Sat`饱和度

怎么考虑优化网络ＩＯ使用率

单次读写数据量小的网络读写数据量大的应用会消耗大量的系统态ＣＰＵ，产生大量的系统调用

当然想优化的话，就要尽量减少网络读写的系统调用。

使用非堵塞的应用框架NIO也可以显著改善网络性能。

建议使用nio框架而不要使用jdk自带的nio实现，它只是一种原始实现。

## 5.8 磁盘ＩＯ使用率

对于有磁盘操作的应用来说，改善性能，自然就要监控磁盘ＩＯ

linux上可以使用`iostat`来监控磁盘ＩＯ使用率

该命令可以监控磁盘IO使用率和系统态cpu使用率

其中`%system`是系统态ＣＰＵ使用率，然后`%util`是磁盘IO使用率

但是这个命令并不能看出是哪个应用在操作磁盘。

直接跳过吧。。。

### 5.8.1 怎么优化磁盘ＩＯ使用率？

1. 更快的存储设备

2. 文件系统扩展到多个磁盘？

3. 操作系统调优，缓存大量文件系统数据结构？

   此外，还有尽量使用带缓存的输入输出流来减少读写次数。

   以及开启磁盘缓存，可以改善严重依赖磁盘ＩＯ的应用的性能。

   但是如果一旦断电的话，可能会导致数据损坏



# 第九章：JVM概览

本章主要讲述的是jvm的架构以及它的主要组件

JVM主要有以下三个组件

1. JVM运行时
2. JIT编译器
3. 内存管理器

## 9.1 HotSpot　VM的基本架构

基本架构就是

垃圾收集器（可插拔）

JIT编译器（可插拔）

HotSpot VM 运行时

​	HotSpot VM 运行时为JIT编译器和垃圾收集器提供服务和通用的API,此外，它还为VM提供启动，线程管理

​	JNI(Java本地接口)等基本功能

内存相关

java堆内存的大小受限于HotSpot版本和操作系统

早期操作系统和hotspot的版本都比较小，所以能用的内存也会比较小

现在大不相同的了，特别是64位的HotSpot　VM 能用的java堆内存就更大

虽然64的寻址对一些应用可能有帮助，但是64的HotSpot有性能损失。

因为内部的java对象指针从32位变成了64位，导致cpu高速缓存行可用的oops变少，从而降低了cpu缓存的效率

不过后来加了压缩指针，使得64位的大内存和cpu效率可以兼得。要通过-xx:+UseCompressedOops开启。

### 9.2 HotSpot　VM运行时

这货担当许多职责。

1. 命令行解析

   可以选定哪个编译器，哪张垃圾搜集器，指定java堆的大小

   命令行选项包含三种

   1. 标准选项：要求所有虚拟机都必须实现的选项
   2. 非标准选择：不强制要求所有虚拟机都必须实现，可能未经通知就在将来的发行版去掉也不一定
   3. 非稳定选项

2. VM生命周期管理

3. 类加载

4. 字节码解释

5. 异常处理

6. 同步

7. 线程管理

8. java本地接口

9. vm致命错误

10. c++堆管理







