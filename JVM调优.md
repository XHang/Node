# JVM 调优

想继续JVM调优，必须先理解JVM虚拟机的内存模型

总的来说，JVM的堆内存在物理上分为两部分

1. **Young Generation** （年轻一代）
2. **Old Generation** （老一代）












##第二章:性能测试

一般来说,软件开发的传统过程是这样的

分析-设计-编码-测试.

但是测试仅仅只是测试功能是否满足需求.

至于性能或者扩展性,那是之后的事了.

当然这样可不行,所以后来才会出现性能测试分析阶段.

要通过这个阶段测试性能是否满足要求

如果不满足,需要返回分析,设计,编码的某个阶段.具体探讨是哪一部分导致了性能问题.

如果满足了,产品才可以继续发布.

当然在需求文档中,必须要有性能需求,不然探讨性能优化就毫无原因了.

举几个吞吐量和延迟性需求

1. 应用预期的吞吐量是多少?

2. 请求和响应之间的延迟预期是多少?

3. 应用支持多少并发任务

4. 把并发任务达到最大值时,应用程序可接受的吞吐量和延迟量是多少?

5. 最差情况的延迟量是多少

6. 如果要使垃圾收集导致的延迟控制在可容忍访问内,

   则垃圾收集的频率应该设计为多少








# 第三章:性能调优方案

## 3.1 定义

改善性能一般涉及到三种不同的活动

1. 性能监控

   指的是非侵入式的收集应用的性能数据的活动.

   一般在找不到性能问题的根本原因时,使用这种方法

   由于是非侵入式,可以在开发,测试,生产环境中使用

2. 性能分析

   这是一种侵入式的收集性能数据的活动,会影响应用的吞吐性或者响应性

   通常在性能监控后执行

3. 性能调优

   这是为了改善应用响应性或者吞吐性的而更改参数,源代码,或者属性配置的活动.

   一般在性能监控或者性能调优后执行

## 第一种:自顶向下

简而言之,就是从软件的栈顶层应用,从上到下一步步寻找优化机会和问题

应用开发人员常用这种方式.

这种方式一般是从发现性能问题的区域(负载)开始监控应用.

监控的范围包括操作系统,JAVA虚拟机,JAVAEE容器以及应用的性能测试统计指标

基于监控信息,来开展下一步工作,比如JVM垃圾收集器调优,JVM命令行选项调优

操作系统调优.





## 第二种:自底向上

就是从最底层的CPU指令数据(比如说CPU高速缓存未命中率,CPU指令效率)开始,逐渐上升到应用的架构上.

将应用迁移到其他操作系统时,或者应用以及部署到生产环境时,也常常使用这种方法

自底向上需要收集最底层CPU的性能统计数据

​	包括执行特定任务所需要的CPU指令数(通常称为路径长度 Path Length)

​	应用在一定负载下运行的CPU高速缓存未命中率.

自底向上一般关注的是不改动应用的情况下,改善CPU使用率.不过通常自底向上也可以为如何修改应用提供建议

# 第四章:选择合适的CPU架构

有时候，性能差仅仅是运行的ＣＰＵ架构或者系统不合适．所以，为应用选择一个合适的ＣＰＵ架构就显得尤为重要．

一般来说，**如果你的应用会有比较多的并发线程，那么推荐的ＣＰＵ架构就是每核多硬件线程**

系统会把每一核的每一个硬件线程都看作一个处理器．

这样的话，在发生长延迟时，比如说ＣＰＵ高速缓存未命中,如果同一个ＣＰＵ核中还有其他就绪的硬件线程，

那么，在下一个时钟周期，就会让这个硬件线程运行，从而减少等待时间．

相反，如果你用的是每核单硬件线程，当发生长延迟事件，就只能等事件完成而浪费事件周期．

并且，如果其他线程已经就绪却没有可用的硬件线程，那么运行前就必须进行线程的切换，而切换，一般要数百个时钟周期．

但是，对于不需要大量并发的应用而言，就没必要选用每核多硬件线程的ＣＰＵ，何况这种ＣＰＵ，它的时钟频率通常比较低，比单核单硬件线程的还要低．

**这种应用的话，还是老老实实选用单核单硬件线程的ＣＰＵ吧**

> 为了评估单核多硬件ＣＰＵ的性能，一般是要加载大量的并发线程的
>
> 另外，单核多硬件线程的ＣＰＵ典型代表型号是Ｏｒａｃｌｅ公司出品的ＳＰＡＲＣ T 系列处理器

# 第五章：操作系统的性能监控

## 5.1 cpu使用率

毋庸置疑,想让应用的性能达到最高,就必须充分榨干CPU周期.

> 值得注意的是,应用消耗很多CPU并不意味着性能达到最高

要找出应用如何使用CPU周期,就要监控CPU使用率.

CPU使用率分为两种

1. 用户型CPU使用率:指的是执行应用程序代码的时间占总CPU时间的百分比

2. 系统型CPU使用率:应用执行操作系统设备调用的时间占总CPU时间的百分比.

   这个CPU使用率高的话,说明应用有共享资源竞争或者IO设备之间有大量的交互

理想情况下,系统型CPU使用率为0时,应用会达到最高的性能.

但是理想是达不到的,我们只能尽量降低系统型CPU使用率

### 5.1.2 监控CPU使用率的工具：Ｌｉｎｕｘ

1. 图形界面

ＬＩＮＵX可以使用ＧＮＯＭＥ System Monitor

通过这个命令启动

`fdggnome-system-monitor ` 

据说只能普通用户启动，超级用户看不到资源和文件系统的栏目

听说还可以用ｘｏｓｖｉｅｗ看ｃｐｕ使用率，但是我用了之后就死机了．．

2. 命令行

   通常用`vmstat`来监控ＣＰＵ使用率，听说加个-w参数会比较好哦

   另外，显示出来的us 是用户型ｃｐｕ使用率，sy是系统型cpu使用率，id是cpu空闲率

   也可以用ｔｏｐ监控ＣＰＵ使用率使用率

   ​

##　5.2:番外篇

对于计算密集型应用，还要关注它的每时钟指令数以及每指令时钟周期．

> 一般平台提供的ＣＰＵ使用率监控是看不到每时钟指令数以及每指令时钟周期的
>
> 所以需要其他骚操作来监控这两货

这是因为即使ＣＰＵ在等待内存中的数据，操作系统工具还是会说ＣＰＵ繁忙．

这种情况被称为停滞，这种停滞还会浪费数几百个时钟周期．

想要提高计算密集型应用的性能时，就要尽量减少停滞和提高ＣＰＵ高速缓存使用率

## 5.3:CPU调度程序运行队列

除了cpu使用率之外,监控cpu调度程序运行队列对于分辨系统是否满负荷也是具有重要的意义.

如果调度程序运行队列很长,则表名系统可能已经满负荷.

当系统运行队列长度等于虚拟处理器个数时,用户不会感受到性能下降.

> 虚拟处理器个数=系统硬件线程个数=Runtime.getRuntime().availableProcessors();

如果系统运行队列长度达到虚拟核心数的4倍或者更多时,系统的响应就很迟缓了

一般说来,只要队列的长度超过虚拟处理器个数的1倍,需要盯紧他,不需要采取行动

如果是超过3-4倍以及更高,就需要采取行动了.

行动1:增加cpu

行动2:研究可以减少应用运行所需cpu周期的葵花宝典,改进cpu使用率

​	比如减少垃圾搜集的频率或者采用更优的算法以减少cpu指令

### 5.3.1 linux上的监控调度程序运行队列

还是要请我们的老朋友`vmstat`

其结果的第一列`procs`就是运行队列长度



## 5.4:内存使用率

内存使用率当然也是衡量性能的一个重要指标.

当运行所需内存超过物理可用内存时,就会发生页面交换.

就是将不常用的内存放进磁盘的swap空间.当要访问到这部分内存时,就要把它从磁盘上置换到内存中,而这种置换会对应用的响应性和吞吐量造成很大的影响.

而且,JVM垃圾搜集器受其系统页面交换,性能也会很差.

其一是因为垃圾搜集要占用很多内存

其二由于占较多内存,则java堆内存的一部分可能会发生页面交换,而垃圾搜集时又得置换进内存以便垃圾收集器扫描存活对象.这使得垃圾搜集会占用更多时间.

其三:垃圾搜集时所有java的应用都要停止.然后你懂得

经验:如果垃圾搜集的时间变长,则表明系统可能正在进行页面交换.

为了验证这一点,必须监控系统的页面交换

### 5.4.1:监控内存使用率:linux

还是老朋友`vmstat`命令,其中`free`列就可以监控页面交换.其实它显示的是空闲内存

要关注的还有`si`和`so`列,分别表示内存页面换入和换出的量.

要留意是否会出现空闲内存少,并且页面调度频繁的情况,相比而言,数量并不是很重要..

