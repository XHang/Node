# <<深入理解虚拟机>>笔记

概要描述一下

这个笔记记录的是一些有用的知识点，但是如果有重复的部分(在虚拟机优化里面讲到的)

就不会记录了

# 一：实战：编译JDK

忽略，该章要求C++能力

# 二：内存管理机制

## 2.1 运行时内存区域

包括

1. 堆
2. 方法区
3. 虚拟机栈
4. 本地方法栈
5. 程序计数器

### 2.1.1 程序计数器

这个内存区域可以看做是记录程序执行的字节码行数

然后有一个字节码解释器，可以更改行号，从而使程序执行下一行字节码，或是循环，或者if语句，这些跳转，都是通过程序计数器来执行的

这个内存区域是线程私有的，为了让处理器切换回线程时，不会丢失当前执行的指令行数，所以要这么设计

这个内存区域还有两大特点

1. 它只有当执行java代码时，才有计数值，如果执行的是native方法，该计数值则为空
2. 该内存区域是JVM虚拟机规范中，唯一没有需要抛出OutOfMemoryError的情况的区域

> 该内存区域JDK8还存活着

### 2.1.2 虚拟机栈

该内存主要是存放局部变量表啊，方法出口，方法栈帧，动态链接什么的，主要是描述Java方法的内存模型

> 局部变量表存放的是基础数据类型，各种对象引用，地址什么的

因为它存放的数据，所以决定了这部分内存，是线程私有的。

我们口里常常说的栈，其实指的就是虚拟机栈

>  对了，由于一个方法在编译时区，变量啊，方法入口什么的都能确定，所以一个方法的局部变量表所需要的内存区域，在编译时期就能完成分配。

该内存区域会抛几个异常

1. StackOverflowError 当请求的栈深度超过虚拟机栈允许的栈深度时，就会抛出此异常，在递归时经常抛

2. 当然，虚拟机栈本身可调（绝大多部分虚拟机可以调整），但是如果调的大小超过了内存限制的话，还会抛出

   OutofMemoryError

> 在32位的windows,多线程的工作情况下，不断的建立线程或者为每一个线程分配的虚拟机栈内存过大很有可能会爆堆内存溢出
>
> 原因是：32位的windows为每一个进程分配的内存大小最大是2GB，JVM也不例外，这部分线程被
>
> 堆，方法区，瓜分后，留给栈的只有那么一点。然后你又为每一个线程安排了过大的内存，这点内存自然就不够分了。所以就会爆OutofMemoryError
>
> 解决方案：
>
> 1. 替换64位的系统
> 2. 减少线程数
> 3. 减少最大堆（分配给栈的内存就多了），减少栈内存（指的是每一个线程占的栈内存）

### 2.1.3 本地方法栈

这个内存区域的定义和虚拟机栈基本一致

但是虚拟机栈描述的是Java方法的内存模型，本地方法栈描述的是本地方法的内存模型

且由于JVM规范中，对本地方法栈的实现没有强制要求，所以有的虚拟机，甚至会把本地方法栈和虚拟机栈合二为一。

抛出异常部分和虚拟机栈一致

### 2.1.4 Java堆

特点

1. 线程公有
2. 虚拟机启动时创建
3. 物理不连续，逻辑连续即可

**堆溢出**

如何才能堆溢出，很简单，创建N多对象，但是Java堆大小限制的小一点。

创建对象到一定数量时，自然就会抛`OutofMenoryError`错误

但是，正常业务开发我们肯定要避免堆溢出这种情况的出现，怎么办。

最好这种溢出BUG能够稳定重现，这样的话，把溢出时的内存dump记录下来。

分析里面的对象，是否必须，还是说发生了内存泄漏（对象不必须却仍然有引用）

简单的处理方法是

1. 重新运行问题程序，但是要加载运行时参数`+`







### 2.1.5 方法区（非堆）

存储的是：虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码

有些人会把这部分区域叫做永久代，因为GC会回收这部分区域

> 回收有：1. 对类的卸载  2. 常量池的回收  

特点

1. 各个线程共享

抛的异常：有些虚拟机用永久代来实现方法区，但是永久代又有内存上限，当方法区的内存超过这个上限时

就会报`OutOfMemoryError`错误

**永久代和方法区的区别**

方法区是JVM规范内存的一部分，而永久代则是用于实现方法区的。

所以，凡是遵循JVM规范的虚拟机，一定有方法区，但却未必有永久代

**永久代的没落**

之前说过，永久代是方法区的一个实现，但是永久代有内存上限，内存不够时会爆`OutOfMemoryError`错误

所以为了解决这个麻烦，从JDK8开始，JVM就没有方法区了，而是新增了nameSpace，这个内存区域可以看做是方法区的一个新实现，而这部分区域，使用的是本地内存，而非Java内存，所以理论上，你的内存有多少。

nameSpace的内存就可以有多少，避免了之前永久代的`OutOfMemoryError`错误

另外：JDK8，字符串常量已经从永久代迁移到堆中了



### 2.1.6 直接内存

直接内存(Direct Memory)并不是虚拟机规范的一部分，但是也会经常使用

比如说，NIO直接使用的就是直接内存

这部分内存不够还是会抛OutofMemory异常

## 2.2 对象

别胡思乱想了，这个对象不是女的，不是雌的，是Java中的对象

### 2.2.1 对象的创建

创建过程

1. 找到new指令后面的参数，从而寻找类

2. 如果类已经加载，则进行下一步，否则该步需要对类进行加载

3. 在堆上创建对象的内存空间，对象的内存空间，在类加载时，就能确定。

   创建对象的内存空间，可能用的是指针碰撞，也有可能用的是空闲列表（请参考虚拟机优化笔记）

   但是不管哪种情况，创建对象的内存空间，都会遇到并发性问题

   就是即将要分配给对象的内存空间，被另一个对象抢先分配了

   解决方法有两个：

   1. 分配过程加同步锁
   2. 给每一个线程，都预先分配一小部分堆内存给它使用，此部分内存被称为TLAB

4. 设置对象属性的零值，正因为如此，所以你的对象变量不需要预先分配值，可以直接使用

5. 设置对象头，填充对象年龄信息，是否启用偏向锁，类的信息，对象哈希码。

6. 执行构造器的内容

### 2.2.2 对象的内存布局

布局：

1. 对象头数据

   1. GC分代年龄
   2. 对象持有的锁
   3. 锁状态标志
   4. 偏向线程ID
   5. 偏向线程ID
   6. 偏向时间戳

   根据32位或者64的虚拟机（未开启压缩指针），这部分数据的长度也是32位或者64位

   这部分数据的内存会物尽及用

   7. 对象类型指针，有些虚拟机实现未必有
   8. 如果对象时数组，还需要记录数组长度

2. 实例数据

   里面包含程序定义里面各种类型的字段内容

3. 对齐填充

   不是必须存在的，存放的是占位符，因为JVM规定对象存放的起始地址，必须是8的整数倍

   换句话说，对象的大小必须是8的整数倍，所以需要这部分数据来凑数

### 2.2.3 对象的访问定位

访问栈上的一个引用数据，从而才能访问到对象

JVM规范只是规定了这件事，但是应该怎么通过访问引用，访问对象，这部分倒没限定。

所以，各个JVM实现，有各种写法。

介绍一下呗

1. 直接指针

   存放的就是对象的地址，直达的那种

   但是这样的话，内存中就得考虑，怎么才能访问这个对象类型数据呢？

   （当然是对象头啦，里面可以有一个类型数据的指针）

   优点：快，直达的那种你说快不快

   缺点：在对象地址移动时(比如说垃圾收集时)，需要重新修改引用的地址

2. 句柄

   使用这个实现会在内存中划分一个句柄池，里面存储对象实例和该对象所属类型数据的具体地址。

   而引用存储的则是句柄池的地址

   也就是说，你想通过引用访问对象，过程是这样

   引用（句柄地址）-------->句柄池（对象和类型具体地址）------->对象

   优点：对象地址移动时，只需要修改句柄池中的对象地址，引用由于存放的是句柄地址，所以不用修改

   缺点：访问对象需要转两遍，积少成多也是很大的开销

就主要的Sun HotSpot虚拟机而言，使用的是直接指针，因为访问对象实在是太频繁和普遍了



## 2.3 小试牛刀

目标：写一个溢出的程序，并将溢出的堆转储到文件中，进行分析

思路：其实并不难，搞一个无限的对象产生，同时，使用命令行限定堆内存大小，最后，加上堆转储命令即可



# 三：JVM运行时参数

## 3.1 ： 介绍运行时参数

首先介绍下JVM运行时参数的种类吧

   命令行选项包含三种

1. 标准选项：要求所有虚拟机都必须实现的选项
2. 非标准选择：不强制要求所有虚拟机都必须实现 开头的选项带有`-x`
3. 非稳定选项 开头的选项带有`--x`

意义:命令行一般是用于控制JVM的内部变量

**选项面面观1:**

对于内部变量为布尔类型的选项来说,只需要添加或者删除就可以控制这些变量.

对于内部变量为布尔类型的非稳定选项来说,选项前面的`+`或者`-`代表true或者false

例如`--x:+AggressiveOpts`就是设置某个内部变量为true以开启

​	`--x:-AggressiveOpts` 就是设置某个内部变量为false以关闭(默认值)

**选项面面观2:**

有些选项长这个样子

`--x:OptionName=<N>`

<N>代表数字,像这种带数字的非稳定选项,数字后面都可以带k,m,g表示千,百万及十亿

**选项面面观3:**

有些选项长得别树一帜,如`XXaltJvm=<name>`

就是`-xx`和选项名之间没有分隔符

甚至有些选项`:` `=`也是没有的

## 3.2 命令行大全解析

### 3.2.1垃圾收集相关

#### 3.2.1.1 垃圾收集器相关

1. `-XX:-UseAdaptiveSizePolicy`  关闭自适应优化

> 当JVM自动优化选择了ThroughPut垃圾收集器，就会开启一个`自适应堆调整`的优化
>
> 就是通过评估对象的分配速率和生命周期，试图优化新生代和老年代的堆大小。
>
> 使得存活期小的对象能被及时回收，允许时间长的对象适时提升，避免不必要的Survivor区的复制。
>
> 自适应Java堆调整不一定适用于所有项目，对于项目的调整性波动，以及对象分配速率的迅速变动，对象生命周期的剧烈变化，自适应java堆调整反而会掉坑，这个时候，就应该关掉自适应调整优化了

2. XX:+ScavengBeforeFullGC  该命令行可以在Full GC 之前，先来一发Minor GC ，减轻Full GC的工作

> 这个选项是布尔类型的，意味着，其实你可以`-XX:+ScavengBeforeFullGC` FullGC 之前不会Minor GC
>
> Full GC之前来一次Minor GC 有什么用呢?
>
> 答：在两个GC执行间隙，应用可以继续运行，这样减少了最大停顿时间，但也使整体停顿时间拉长

3. `-XX:MaxTenuringThreshold=<n>`可以设置新生代的晋升阈值

2. `-XX:UseParNewGC` 可以在新生代使用parNew垃圾收集器

3. `-XX:SurvivorRatio=<ratio>`这个是单个Survivor空间和Eden空间的大小的比率,默认值为8

#### 3.2.1.2 调整分代大小

1. `-XX:PermSize=xxM 和 -XX:MaxPermSize=xxM`  两者可调整永久代大小

2. 设定新生代+老年代空间的内存空间
   新生代+老年代最小值(初始值)：`-Xms<n>[g|m|k]`
   新生代+老年代最大值:``-Xmx<n>[g|m|k]``
   关注吞吐量和延迟的java程序应该把这两个值设定为一样。
   因为这个内存空间无论是扩展还是缩减都是要Full GC的。

   一样的话不会内存自动拓展的

3. 设定新生代的内存空间
   `-XX:NewSize=<n>[g|m|k]`
   这个可以设定新生代内存的初始值，也是最小值
   其中<n>是设定的大小，g,m,k指的是度量的单位
   新生代空间的大小不会小于这个值
   既然设定了最小值，那自然也要同时设定一下新生代的最大值`-XX:MaxNewSize=<n>[g|m|k]`
   同理，新生代的空间也不会超过这个值

> ps:只是说初始值和最大值在手动设定时应该同时指定，但不是强制要求

3. 设定新生代的大小
   最后，有一个东东，可以同时把新生代的初始值，最小值，最大值都设定为同一个值
   `-Xmn<n>[g|m|k]`
   新生代的大小会根据这个值进行设定

#### 3.2.1.3 查垃圾收集信息

1. `-XX:+PrintGCDetails`可以打印很多有价值的垃圾收集器信息。

2. `-XX:+PrintCommandLineFlags` 这个可以打印出JVM启动的命令行参数，可以用于查看堆的初始值和最大值

   > 打印的结果如下
   >
   > ```
   > -XX:InitialHeapSize=132301888 
   > -XX:MaxHeapSize=2116830208 
   > -XX:+PrintCommandLineFlags 
   > -XX:+UseCompressedClassPointers 
   > -XX:+UseCompressedOops 
   > -XX:-UseLargePagesIndividualAllocation 
   > -XX:+UseParallelGC
   > ```

3. `-XX:+PrintTenuringDistribution` 可以打印出对象年龄的分布 

4. `-XX:+PrintGCApplicationConcurrentTime` 可以报告应用在安全点操作之间的运行时间

5. `-XX:+PrintGCApplicationStoppedTime` 这个是堵塞java线程的时间

   > 使用了这4、5选项后的GC日志
   >
   > ```
   > 1.248: Application time: 0.1672635 seconds
   > 1.248: [GC (Allocation Failure) [PSYoungGen: 31128K->5118K(36864K)] 31128K->10950K(121856K), 0.0339035 secs] [Times: user=0.05 sys=0.00, real=0.03 secs] 
   > 
   > 1.283: Total time for which application threads were stopped: 0.0341715 seconds, Stopping threads took: 0.0000153 seconds
   > ```
   > 第一行表示Java应用运行大约0.1672635秒，Minor GC大约停顿0.0341715 秒
   >
   > 两个值比对一下，可以得出Minor GC 大约有2%的开销

6. `-Xloggc:<filename>`可以将垃圾收集的日志存储在文件中，以便离线分析

   此日志结合`-XX:+PrintGCDetails`可以在输出的日志文件中，打印出时间戳(秒数)

7. `-XX:+PrintGCTimeStamps`打印自JVM启动以来的秒数

8. `-XX:+PrintGCDateStamps`打印符合ISO8601标准的时间戳

   这些时间戳可以推断出Minor GC和Full GC的持续时间和频率

9. `-XX:+HeapDumpOnOutOfMemoryError`  将发生堆溢出时的内存映像dump下来。

   默认保存在JDK安装目录内

10. `-XX:+PrintTenuringDistribution`这个可以监控对象的年龄分布。

    > 其实吧，用`VisuaIVM的VisualGC插件`也是可以监控对象的年龄分布的。



### 3.2.2 编译器相关

`-XX:+PrintCompilation`  打印JIT编译器的工作详情

> 关于怎么看该文件，可以查看JVM优化的笔记





